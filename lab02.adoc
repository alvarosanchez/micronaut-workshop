== Implementing a data access layer with Micronaut Data JDBC (60 minutes)

TIP: Change to the `lab02` directory to work on this exercise

In this exercise, you will create a data access layer
using https://micronaut-projects.github.io/micronaut-data/latest/guide/[Micronaut Data JDBC]. This library provides a
convenient way to create repositories that can be used to perform CRUD operations on a database.

For development and testing on a real database, we are going to use https://www.postgresql.org/[PostgreSQL] via
https://micronaut-projects.github.io/micronaut-test-resources/latest/guide/[Micronaut Test Resources].

=== Preparing the project (15 minutes)

Before going any further, make sure you have a recent version of `postgres:latest` pulled in your Docker environment.

icon:hand-o-right[] Execute the following command

  docker pull postgres:latest

icon:hand-o-right[] Now, create a new application:

    curl 'https://launch.micronaut.io/create/default/com.example.micronaut.clubs?lang=JAVA&build=MAVEN&test=JUNIT&javaVersion=JDK_21&features=graalvm&features=data-jdbc&features=postgres' --output clubs.zip

icon:hand-o-right[] Unzip `clubs.zip` and import the project in your IDE.

Also, to set up the schema and add some sample data, we are going to use
https://micronaut-projects.github.io/micronaut-test/latest/guide/#sql[Micronaut Test's `@Sql`] annotation.

icon:hand-o-right[] Create the following migration files:

.Click to expand
[%collapsible]
====
.`src/main/resources/create.sql`
[source,sql]
----
include::./lab02/solution/clubs/src/main/resources/create.sql[]
----

.`src/main/resources/data.sql`
[source,sql]
----
include::./lab02/solution/clubs/src/main/resources/data.sql[]
----

.`src/main/resources/clean.sql`
[source,sql]
----
include::./lab02/solution/clubs/src/main/resources/clean.sql[]
----
====

Also, to prevent Micronaut Data's built-in schema generation to conflict with the schema we are going to create, you need
to remove the following line from `application.properties`:

[source,properties]
----
datasources.default.schema-generate=CREATE_DROP
----

=== Implementing the data access layer (15 minutes)

For the data access layer, we are going to use the https://micronaut-projects.github.io/micronaut-data/latest/guide/#jdbc[Micronaut Data] library in its JDBC flavour. In the source code, we will use
standard JPA annotations.

icon:hand-o-right[] Add the following dependency:

[source,xml]
----
include::./lab02/solution/clubs/pom.xml[tag=jpa,indent=0]
----
<1> It is in `provided` scope to make it available during compilation, so that the Micronaut annotation processor can
    generate the corresponding beans, but it is not included in the final JAR since at runtime we will not use JPA but
    Micronaut Data JDBC.

icon:hand-o-right[] Create the following entity model:

ifdef::generate-diagrams[]
[plantuml, entity-model, png]
....
entity Club <<record>> {
  id: Long
  name: String
  stadium: String
}
note top of Club
  @Entity
  @Serdeable
end note
note right of Club::id
  @Id
  @GeneratedValue
end note

interface CrudRepository {}
interface ClubRepository<Club, Long> {}
note top of ClubRepository
  @JdbcRepository(dialect = Dialect.POSTGRES)
end note
CrudRepository <|-- ClubRepository
ClubRepository -- Club
....
endif::[]

image::entity-model.png[]

* `Club` is a JPA entity, so it is annotated with `@Entity`. It is also annotated with `@Serdeable` so that it can be
  serialized and deserialized by Micronaut Serialization.
* `ClubRepository` is a Micronaut Data JDBC repository. It extends `CrudRepository` so that it inherits the basic CRUD
    operations. It is annotated with `@JdbcRepository` so that it is recognized by Micronaut Data JDBC. The `dialect`
    attribute is set to `Dialect.POSTGRES` so that the queries generated at compile time work with PostgreSQL.

WARNING: In a real-world application, you should not expose your JPA entities directly to the outside world. Instead, you
should create DTOs (Data Transfer Objects) that represent the data you want to expose. This is a good practice to avoid
leaking implementation details and to have more control over the data you expose. In this exercise, we are exposing the
JPA entities directly for simplicity.

We can write a simple test to make sure everything is working as expected.

icon:hand-o-right[] Create the following test:

.Click to expand
[%collapsible]
====
[source,java]
----
include::./lab02/solution/clubs/src/test/java/com/example/micronaut/ClubRepositoryTest.java[tag=test]
----
<1> The `@Sql` annotation is used to execute the SQL scripts before and after the test.
<2> Micronaut can inject dependencies in test methods.
====

=== Implementing the REST API (15 minutes)

icon:hand-o-right[] Create the following REST API:

ifdef::generate-diagrams[]
[plantuml, rest-api, png]
....
interface ClubClient {}
interface ClubRepository<Club, Long> {}
interface ClubApi {
  list(): Iterable<Club>
  get(id: Long): HttpResponse<Club>
}
note right of ClubApi::get
  @Get("/{id}")
end note

class ClubController {
}
note top of ClubController
  @Controller("/clubs")
end note

ClubApi <|-- ClubController
ClubApi <|-- ClubClient
ClubController -- ClubRepository : uses
....
endif::[]

image::rest-api.png[]

* `ClubApi` is an API contract with REST operations. It will be implemented by `ClubController`, and a `ClubClient` we
  will create later. For each method annotated with `@Get`, `@Post`, `@Put`, `@Delete`, etc., Micronaut will figure out
  how to render the corresponding JSON response based on the return type, which can be POJOs or collections of POJOs,
  or wrapped in `HttpResponse` when we need to customise the response (header, response codes, etc).
* `ClubController` is a Micronaut controller. It is annotated with `@Controller`, and uses `ClubRepository` to implement
  the operations.

WARNING: In a real-world scenario, a controller should not interact directly with a repository. Instead, it should use a
service layer that encapsulates the business logic. This is a good practice to separate concerns and make the code more
testable. In this exercise, we are using the repository directly for simplicity.

We can now write a functional test for this REST API. In this case, instead of using the low-level HTTP client, we are
going to use a declarative client. For this, we are going to leverage the `ClubApi` interface we have just created.

icon:hand-o-right[] Create the following test:

.Click to expand
[%collapsible]
====
[source,java]
----
include::./lab02/solution/clubs/src/test/java/com/example/micronaut/ClubControllerTest.java[tags=test;clazz]
----
<1> The `@Client` annotation is mapped to the same path as the controller. The implementation of this interface will be
    generated by Micronaut at compile time.
<2> The `@Inject` annotation is used to inject an instance of the generated client.
====

In order to see the HTTP requests and responses, and also the SQL queries, we can declare the following loggers:

.`src/main/resources/logback.xml`
[source,xml]
----
include::./lab02/solution/clubs/src/main/resources/logback.xml[tag=loggers,indent=0]
----

=== Completing the REST API (15 minutes)

icon:hand-o-right[] Using the knowledge acquired in the previous exercises, you can now complete the REST API by implementing the following
endpoints:

* `POST /clubs`: creates a new club.
* `PUT /clubs/{id}`: updates an existing club.
* `DELETE /clubs/{id}`: deletes an existing club.

icon:hand-o-right[] Augment the functional test to cover the new endpoints. Test also negative cases such as providing
non-existing IDs, or invalid payloads.