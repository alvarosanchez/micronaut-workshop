== Implementing a data access layer with Micronaut Data JDBC (~90 minutes)

TIP: Change to the `lab02` directory to work on this exercise

In this exercise, you will create a data access layer
using https://micronaut-projects.github.io/micronaut-data/latest/guide/[Micronaut Data JDBC]. This library provides a
convenient way to create repositories that can be used to perform CRUD operations on a database.

For development and testing on a real database, we are going to use https://www.postgresql.org/[PostgreSQL] via
https://micronaut-projects.github.io/micronaut-test-resources/latest/guide/[Micronaut Test Resources].

=== Preparing the project (15 minutes)

Before going any further, make sure you have a recent version of `postgres:latest` pulled in your Docker environment.

icon:hand-o-right[] Execute the following command

  docker pull postgres:latest

icon:hand-o-right[] Now, create a new application:

    curl 'https://launch.micronaut.io/create/default/com.example.micronaut.clubs?lang=JAVA&build=MAVEN&test=JUNIT&javaVersion=JDK_21&features=graalvm&features=data-jdbc&features=postgres' --output clubs.zip

icon:hand-o-right[] Unzip `clubs.zip` and import the project in your IDE.

Also, to set up the schema and add some sample data, we are going to use
https://micronaut-projects.github.io/micronaut-test/latest/guide/#sql[Micronaut Test's `@Sql`] annotation.

icon:hand-o-right[] Create the following migration files:

.Click to expand
[%collapsible]
====
.`src/main/resources/create.sql`
[source,sql]
----
include::./lab02/solution/clubs/src/main/resources/create.sql[]
----

.`src/main/resources/data.sql`
[source,sql]
----
include::./lab02/solution/clubs/src/main/resources/data.sql[]
----

.`src/main/resources/clean.sql`
[source,sql]
----
include::./lab02/solution/clubs/src/main/resources/clean.sql[]
----
====

Also, to prevent Micronaut Data's built-in schema generation to conflict with the schema we are going to create, you need
to remove the following line from `application.properties`:

[source,properties]
----
datasources.default.schema-generate=CREATE_DROP
----

=== Implementing the entities (20 minutes)

For the data access layer, we are going to use the
https://micronaut-projects.github.io/micronaut-data/latest/guide/#jdbc[Micronaut Data] library in its JDBC flavour. In
the source code, we will use standard JPA annotations.

icon:hand-o-right[] Add the following dependency:

[source,xml]
----
include::./lab02/solution/clubs/pom.xml[tag=jpa,indent=0]
----
<1> It is in `provided` scope to make it available during compilation, so that the Micronaut annotation processor can
    generate the corresponding beans, but it is not included in the final JAR since at runtime we will not use JPA but
    Micronaut Data JDBC.

icon:hand-o-right[] Create the following entity model:

ifdef::generate-diagrams[]
[plantuml, entity-model, png]
....
entity Club <<record>> {
  id: Long
  name: String
  stadium: Stadium
}
note top of Club
  @Entity
end note
note right of Club::id
  @Id
  @GeneratedValue
end note
note right of Club::stadium
  @OneToOne(cascade = CascadeType.PERSIST)
  @JoinColumn
end note

entity Stadium <<record>> {
  id: Long
  name: String
  city: String
  country: String
}
note top of Stadium
  @Entity
end note
note right of Stadium::id
  @Id
  @GeneratedValue
end note

interface CrudRepository {}
interface ClubRepository<Club, Long> {}
note top of ClubRepository
  @JdbcRepository(dialect = Dialect.POSTGRES)
  @Join("stadium")
end note
CrudRepository <|-- ClubRepository
ClubRepository -- Club
Club *-- Stadium
....
endif::[]

image::entity-model.png[]

* `Club` is a JPA entity, so it is annotated with `@Entity`. It has a `@OneToOne` relationship with `Stadium`. The
  `@JoinColumn` annotation is used to specify the column that will be used to join the two tables. The `@Id` and
  `@GeneratedValue` annotations are used to specify that the `id` field is the primary key and that it is automatically
  generated by the database.
* `Stadium` is another JPA entity. It is also annotated with `@Entity`.
* `ClubRepository` is a Micronaut Data JDBC repository. It extends `CrudRepository` so that it inherits the basic CRUD
  operations. It is annotated with `@JdbcRepository` so that it is recognized by Micronaut Data JDBC. The `dialect`
  attribute is set to `Dialect.POSTGRES` so that the queries generated at compile time work with PostgreSQL. The
  `@Join` annotation is used to specify that the `stadium` field should be eagerly fetched when querying the `Club`   entity.

We can write a simple test to make sure everything is working as expected.

icon:hand-o-right[] Create the following test:

.Click to expand
[%collapsible]
====
[source,java]
----
include::./lab02/solution/clubs/src/test/java/com/example/micronaut/ClubRepositoryTest.java[tag=test]
----
<1> The `@Sql` annotation is used to execute the SQL scripts before and after the test.
<2> Micronaut can inject dependencies in test methods.
====

=== Implementing the data transfer objects (15 minutes)

In this REST API, the club and stadium are represented together. The fact that they are separate entities is an
implementation detail that should not be exposed to the client. To solve this, we are going to create a data transfer
object (DTO) that represents how the clubs are rendered.

icon:hand-o-right[] Create the following DTO:

ifdef::generate-diagrams[]
[plantuml, dtos, png]
....
class ClubDto <<record>> {
  id: Long
  name: String
  stadium: String
}
note top of ClubDto
  @Serdeable
end note
....
endif::[]

image::dtos.png[]

The `@Serdeable` annotation is used to indicate that the class can be serialized and deserialized by
https://micronaut-projects.github.io/micronaut-serialization/latest/guide/[Micronaut Serialization].

To map from the entity to the DTO and vice versa, we are going to use Micronaut's built-in
https://docs.micronaut.io/latest/guide/#beanMappers[bean mappers].

icon:hand-o-right[] Create the following mapper:

.Click to expand
[%collapsible]
====
[source,java]
----
include::./lab02/solution/clubs/src/main/java/com/example/micronaut/clubs/ClubMapper.java[tag=mapper]
----
<1> The `@Mapping` annotation is used to specify how the fields should be mapped when a custom mapping is needed between
    fields. Fields whose names are the same are automatically mapped. In this case, we need to map the `stadium` field
    from the entity to the `stadium` field of the DTO. The string representation of the stadium is determined by
    `Stadium::toString`. The value of the `from` attribute is using
    https://docs.micronaut.io/latest/guide/#evaluatedExpressions[Micronaut's Expression Language].
<2> For the reverse mapping, we need to unwind the previous conversion and parse the string into a `Stadium` object. In
    this case, we are using a default method in the interface, which is called from the Micronaut expression.
<3> The parsing implementation splits the string into the different fields of `Stadium`.
<4> `Stadium::of` is a utility method to create a `Stadium` object from a name, city, and country. Please create such a
    method in the `Stadium` class, passing `null` for the `id` field.
====

WARNING: Ideally there should be a `StadiumDto` and implement its own mapping from/to entities in a less fragile way that
does not imply string parsing. But for the sake of simplicity, we are going to use the current approach.

=== Implementing the service layer (15 minutes)

Since we don't want the controller to interact directly with the repository, we are going to create a service layer that
encapsulates the business logic. This service layer will use the repository and the mapper to perform the operations.

icon:hand-o-right[] Create the following service:

ifdef::generate-diagrams[]
[plantuml, service, png]
....
class ClubService {
  repository: ClubRepository
  mapper: ClubMapper

  ClubDto save(ClubDto clubDto)
  Optional<ClubDto> update(ClubDto clubDto)
  void delete(Long id)
  Optional<ClubDto> findById(Long id)
  Collection<ClubDto> findAll()
  boolean existsById(Long id)
}
note top of ClubService
  @Singleton
end note
....
endif::[]

image::service.png[]

If in doubt, check the solution in the `lab02/solution` directory.

=== Implementing the REST API (15 minutes)

icon:hand-o-right[] Create the following REST API:

ifdef::generate-diagrams[]
[plantuml, rest-api, png]
....
interface ClubClient {}
class ClubService {}
interface ClubApi {
  Collection<ClubDto> list()
  HttpResponse<ClubDto> get(Long id)
}
note right of ClubApi::list
  @Get
end note
note right of ClubApi::get
  @Get("/{id}")
end note

class ClubController {
}
note top of ClubController
  @Controller("/clubs")
end note

ClubApi <|-- ClubController
ClubApi <|-- ClubClient
ClubController -- ClubService : uses
....
endif::[]

image::rest-api.png[]

* `ClubApi` is an API contract with REST operations. It will be implemented by `ClubController`, and a `ClubClient` we
  will create later. For each method annotated with `@Get`, `@Post`, `@Put`, `@Delete`, etc., Micronaut will figure out
  how to render the corresponding JSON response based on the return type, which can be POJOs or collections of POJOs,
  or wrapped in `HttpResponse` when we need to customise the response (header, response codes, etc).
* `ClubController` is a Micronaut controller. It is annotated with `@Controller`, and uses `ClubService` to implement
  the operations.

We can now write a functional test for this REST API. In this case, instead of using the low-level HTTP client, we are
going to use a declarative client. For this, we are going to leverage the `ClubApi` interface we have just created.

icon:hand-o-right[] Create the following test:

.Click to expand
[%collapsible]
====
[source,java]
----
include::./lab02/solution/clubs/src/test/java/com/example/micronaut/ClubControllerTest.java[tags=test;clazz]
----
<1> The `@Client` annotation is mapped to the same path as the controller. The implementation of this interface will be
    generated by Micronaut at compile time.
<2> The `@Inject` annotation is used to inject an instance of the generated client.
====

In order to see the HTTP requests and responses, and also the SQL queries, we can declare the following loggers
(nested in the `<configuration>` element):

.`src/main/resources/logback.xml`
[source,xml]
----
include::./lab02/solution/clubs/src/main/resources/logback.xml[tag=loggers,indent=0]
----

=== Completing the REST API (15 minutes)

icon:hand-o-right[] Using the knowledge acquired in the previous exercises, you can now complete the REST API by implementing the following
endpoints:

* `POST /clubs`: creates a new club.
* `PUT /clubs/{id}`: updates an existing club.
* `DELETE /clubs/{id}`: deletes an existing club.

icon:hand-o-right[] Augment the functional test to cover the new endpoints. Test also negative cases such as providing
non-existing IDs, or invalid payloads.